# Анализ калькулятора доходности майнинга

## Критические проблемы

### 1. ПРОБЛЕМА С ЕДИНИЦАМИ ИЗМЕРЕНИЯ ХЕШРЕЙТА

**Местоположение:** `utils/calculator.py`, строки 49-53

**Проблема:**
```python
miner_hash = hash_rate  # Берется из модели ASIC (может быть в TH/s, GH/s, MH/s)
network_hash = info["network_hashrate"]  # Из базы данных (в разных единицах!)
share = miner_hash / network_hash  # ОШИБКА: единицы не совпадают!
```

**Детали:**
- В базе данных `network_hashrate` хранится в разных единицах для разных алгоритмов:
  - SHA-256: `650_000_000` (предположительно TH/s, но это 650 PH/s - слишком много!)
  - Scrypt: `600_000` (предположительно MH/s = 0.6 TH/s)
  - Etchash: `50_000_000` (предположительно MH/s = 50 TH/s)
  - kHeavyHash: `300_000` (предположительно GH/s = 300 TH/s)
  - Blake2S: `3_000` (предположительно GH/s = 3 TH/s)
  - Blake2B+SHA3: `200` (предположительно GH/s = 0.2 TH/s)

- В модели ASIC `hash_rate` может быть в разных единицах в зависимости от алгоритма:
  - SHA-256: обычно в TH/s (например, 100 TH/s)
  - Scrypt: обычно в MH/s (например, 1000 MH/s)
  - kHeavyHash: обычно в GH/s (например, 100 GH/s)

**Последствия:**
- Неправильный расчет доли майнера в сети
- Завышенная или заниженная доходность
- Неточные результаты для пользователей

**Пример ошибки:**
```
Для SHA-256:
- miner_hash = 100 TH/s
- network_hash = 650_000_000 (если это TH/s, то 650 PH/s - нереально!)
- share = 100 / 650_000_000 = 0.00000015 (слишком мало!)

Правильно должно быть:
- network_hash для BTC сейчас ~650 PH/s = 650_000 TH/s
- share = 100 / 650_000 = 0.00015 (правильно)
```

---

### 2. ПРОБЛЕМА С РАСЧЕТОМ КОЛИЧЕСТВА МОНЕТ

**Местоположение:** `utils/calculator.py`, строка 73

**Проблема:**
```python
def make_period(multiplier: int) -> Dict[str, Any]:
    coins_per_coin = {}
    for symbol, coin in coin_data.items():
        coins = (daily_income_usd / coin["price"]) * multiplier  # НЕПРАВИЛЬНО!
        coins_per_coin[symbol] = coins
```

**Детали:**
- `daily_income_usd` уже рассчитан для первой монеты из `coin_data`
- При расчете для других монет используется `daily_income_usd / coin["price"]`, что неправильно
- Нужно использовать `daily_coins` напрямую, так как это количество монет, а не долларов

**Правильный расчет:**
```python
coins = daily_coins * multiplier  # Для всех монет одинаково
```

**Последствия:**
- Неправильное количество монет для всех монет кроме первой
- Пользователи видят неверные данные о доходности в монетах

---

### 3. ОТСУТСТВИЕ НОРМАЛИЗАЦИИ ЕДИНИЦ

**Проблема:**
Код не приводит единицы измерения к одному стандарту перед расчетом.

**Решение:**
Нужно нормализовать все значения к одной единице (например, H/s):

```python
# Множители для конвертации в H/s
UNIT_MULTIPLIERS = {
    "th/s": 1_000_000_000_000,  # TH/s -> H/s
    "gh/s": 1_000_000_000,      # GH/s -> H/s
    "mh/s": 1_000_000,          # MH/s -> H/s
    "kh/s": 1_000,              # KH/s -> H/s
    "h/s": 1                    # H/s -> H/s
}

# Нормализация
miner_hash_hs = miner_hash * UNIT_MULTIPLIERS[unit]
network_hash_hs = network_hash * UNIT_MULTIPLIERS[network_unit]
share = miner_hash_hs / network_hash_hs if network_hash_hs > 0 else 0
```

---

### 4. НЕСООТВЕТСТВИЕ ДАННЫХ В БАЗЕ

**Проблема:**
Значения `network_hashrate` в базе данных могут быть в неправильных единицах или устаревшими.

**Примеры из `database/models.py`:**
- SHA-256: `650_000_000` - если это TH/s, то 650 PH/s (реально сейчас ~650 PH/s, но записано как 650M TH/s)
- Scrypt: `600_000` - если это MH/s, то 0.6 TH/s (нужно проверить актуальность)
- kHeavyHash: `300_000` - если это GH/s, то 300 TH/s (нужно проверить)

**Рекомендация:**
- Уточнить единицы измерения для каждого алгоритма
- Обновить значения актуальными данными
- Добавить поле `hashrate_unit` в таблицу `algorithm_data`

---

### 5. ПРОБЛЕМА С EFFICIENCY_FACTOR

**Местоположение:** `utils/calculator.py`, строка 61

**Проблема:**
```python
daily_coins *= algo_params["efficiency_factor"]  # Всегда 1.0
```

**Детали:**
- `efficiency_factor` всегда равен 1.0 для всех алгоритмов
- Не учитываются потери на пуле (обычно 1-2%)
- Не учитываются задержки сети и неидеальная работа оборудования

**Рекомендация:**
Установить `efficiency_factor = 0.98` или `0.99` для учета реальных потерь.

---

### 6. ПРОБЛЕМА С БЛОК-ТАЙМОМ

**Местоположение:** `utils/calculator.py`, строки 55-58

**Проблема:**
Значения `block_time` могут быть неточными:
- SHA-256: 600 сек (10 мин) - правильно
- Scrypt: 150 сек (2.5 мин) - нужно проверить для LTC
- Etchash: 13 сек - нужно проверить для ETC

**Рекомендация:**
Проверить актуальные значения block_time для каждого алгоритма.

---

## Рекомендации по исправлению

### Приоритет 1 (Критично):
1. ✅ **Нормализовать единицы измерения** перед расчетом `share`
2. ✅ **Исправить расчет `coins_per_coin`** - использовать `daily_coins` напрямую
3. ✅ **Проверить и исправить значения `network_hashrate`** в базе данных

### Приоритет 2 (Важно):
4. ✅ Добавить поле `hashrate_unit` в таблицу `algorithm_data`
5. ✅ Добавить проверки и валидацию единиц измерения
6. ✅ Добавить логирование для отладки расчетов

### Приоритет 3 (Улучшения):
7. ✅ Установить `efficiency_factor = 0.98-0.99`
8. ✅ Проверить и обновить `block_time` для всех алгоритмов
9. ✅ Добавить комментарии в код для ясности

---

## Пример правильного расчета

```python
# 1. Определяем единицы
algo_params = get_algorithm_params(algorithm)
miner_unit = algo_params["hashrate_unit"]  # например, "th/s"
network_unit = "th/s"  # нужно получать из базы данных!

# 2. Нормализуем к H/s
miner_hash_hs = miner_hash * UNIT_MULTIPLIERS[miner_unit]
network_hash_hs = network_hash * UNIT_MULTIPLIERS[network_unit]

# 3. Рассчитываем долю
share = miner_hash_hs / network_hash_hs if network_hash_hs > 0 else 0

# 4. Рассчитываем монеты
blocks_per_day = 86400 / block_time
daily_coins = share * blocks_per_day * block_reward * efficiency_factor

# 5. Рассчитываем доход
daily_income_usd = daily_coins * coin_price

# 6. Для всех монет используем daily_coins
coins_per_coin = {symbol: daily_coins * multiplier for symbol in coin_data.keys()}
```

---

## Заключение

Основные проблемы:
1. **Несоответствие единиц измерения** - критическая ошибка
2. **Неправильный расчет монет** - влияет на отображение результатов
3. **Устаревшие/неправильные данные в БД** - нужно обновить

Эти проблемы приводят к неточным расчетам доходности, что объясняет жалобы пользователей.

